
### 主从复制

为避免单点故障，保证高可用，使用冗余（副本）方式提供集群服务。 redis 提供了主从库模式，保证数据副本的一致，主从库之间采用读写分离的方式。

#### 主从复制概述

指 将一台 Redis 服务器的数据，复制到其他 Redis 服务器。主节点（master），从节点（slave）; 数据的复制是单向的，只能主节点到从节点。

#### 作用

- 数据冗余： 实现了数据的热备份，是持久化之外的一种方式。
- 故障恢复： 主节点出现问题时，可以由从节点提供服务，实现快速故障恢复； 实际上时一种服务的冗余。
- 负载均衡： 主从复制的基础上，配合读写分离，可以由主节点提供写服务，从节点提供读服务 （即写数据连接主节点，读数据连接从节点），分担服务器负载；写少读多的场景下，大大提高并发量。
- 高可用基石： 主从复制是哨兵和集群的基础，因此说主从复制是 Redis 高可用的基础。

读写分离：

- 读操作： 主、从库都可以接收。
- 写操作： 首先到主库进行，然后主库将写操作同步给从库。

![读写分离](https://static001.geekbang.org/resource/image/80/2f/809d6707404731f7e493b832aa573a2f.jpg)

#### 全量复制

第一阶段，主从库建立连接、协商同步。

第二阶段，主库将所有数据同步给从库。

第三阶段，主库把第二阶段执行过程中新收到的写命令，再发送给从库。

#### 增量复制

如果主库在命令传播时出现了网络闪断，重新进行一次全量复制的开销非常大。

repl_backlog_buffer：它是为了从库断开之后，如何找到主从差异数据而设计的环形缓冲区，从而避免全量复制带来的性能开销。

replication buffer：Redis和客户端通信也好，和从库通信也好，Redis都需要给分配一个
内存buffer进行数据交互，客户端是一个client，从库也是一个client，我们每个client连上Redis后，Redis都会分配一个client
buffer，所有数据交互都是通过这个buffer进行的：Redis先把数据写到这个buffer中，然后再把buffer中的数据发到client
socket中再通过网络发送出去，这样就完成了数据交互。所以主从在增量同步时，从库作为一个client，也会分配一个buffer，只不过这个buffer专门用来传播用户的写命令到从库，保证主从数据一致，我们通常把它叫做replication
buffer。

- 如果在网络断开期间，repl_backlog_size环形缓冲区写满之后，从库是会丢失掉那部分被覆盖掉的数据，还是直接进行全量复制呢？

        1. 一个从库如果和主库断连时间过长，造成它在主库repl_backlog_buffer的slave_repl_offset位置上的数据已经被覆盖掉了，此时从库和主库间将进行全量复制。

        2. 每个从库会记录自己的slave_repl_offset，每个从库的复制进度也不一定相同。在和主库重连进行恢复时，从库会通过psync命令把自己记录的slave_repl_offset发给主库，主库会根据从库各自的复制进度，来决定这个从库可以进行增量复制，还是全量复制。

#### 当主服务器不进行持久化时复制的安全性

在进行主从复制设置时，强烈建议在主服务器上开启持久化，当不能这么做时，比如考虑到延迟的问题，应该将实例配置为避免自动重启。

例子：

有主服务器 A，关闭持久化， 从节点 B， 从节点 C。

出现崩溃，主服务器自动重启，关闭了持久化，重启后数据集为空。

此时，B C 复制 A， A 为空， B C 会删除自己的复制数据。

造成数据丢失。

#### 为什么主从全量复制使用RDB而不使用AOF？

    1. RDB文件内容是经过压缩的二进制数据（不同数据类型数据做了针对性优化），文件很小。
       而AOF文件记录的是每一次写操作的命令，写操作越多文件会变得很大，其中还包括很多对同一个key的多次冗余操作。
       在主从全量数据同步时，传输RDB文件可以尽量降低对主库机器网络带宽的消耗，从库在加载RDB文件时，一是文件小，读取整个文件的速度会很快，二是因为RDB文件存储的都是二进制数据，从库直接按照RDB协议解析还原数据即可，速度会非常快，而AOF需要依次重放每个写命令，这个过程会经历冗长的处理逻辑，恢复速度相比RDB会慢得多，所以使用RDB进行主从全量复制的成本最低。
    
    2. 假设要使用AOF做全量复制，意味着必须打开AOF功能，打开AOF就要选择文件刷盘的策略，选择不当会严重影响Redis性能。
       而RDB只有在需要定时备份和主从全量复制数据时才会触发生成一次快照。而在很多丢失数据不敏感的业务场景，其实是不需要开启AOF的。

#### 无磁盘复制模式

Redis 默认是磁盘复制，但是如果使用比较低速的磁盘，这种操作会给主服务器带来较大的压力。

无磁盘复制模式：master创建一个新进程直接dump RDB到slave的socket，不经过主进程，不经过硬盘。适用于disk较慢，并且网络较快的时候。

#### 主 - 从 - 从

一次全量复制，对于主库需要完成两个耗时操作： 生成 RDB 文件和传输 RDB 文件。

将主库生成 RDB 和 传输 RDB 的压力，以级联的方式分散到从库上。

我们在部署主从集群的时候，手动选择一个从库，用于级联其他的从库。然后再选择一些从库，和刚才所选从库建立主从关系。

#### 读写分离 问题

- 延迟与不一致问题

        主从复制命令传播时异步的，延迟与数据不一致不可避免。

如果应用对数据不一致的接受程度程度较低，可能的优化措施包括：优化主从节点之间的网络环境（如在同机房部署）；监控主从节点延迟（通过offset）判断，如果从节点延迟过大，通知应用不再通过该从节点读取数据；使用集群同时扩展写负载和读负载等。

- 数据过期问题

在单机版Redis中，存在两种删除策略：

        惰性删除：服务器不会主动删除数据，只有当客户端查询某个数据时，服务器判断该数据是否过期，如果过期则删除。 

        定期删除：服务器执行定时任务删除过期数据，但是考虑到内存和CPU的折中（删除会释放内存，但是频繁的删除操作对CPU不友好），该删除的频率和执行时间都受到了限制。

在主从复制场景下，为了主从节点的数据一致性，从节点不会主动删除数据，而是由主节点控制从节点中过期数据的删除。由于主节点的惰性删除和定期删除策略，都不能保证主节点及时对过期数据执行删除操作，因此，当客户端通过Redis从节点读取数据时，很容易读取到已经过期的数据。

Redis 3.2中，从节点在读取数据时，增加了对数据是否过期的判断：如果该数据已过期，则不返回给客户端；将Redis升级到3.2可以解决数据过期问题。

- 故障切换问题

在没有使用哨兵的读写分离场景下，应用针对读和写分别连接不同的Redis节点；当主节点或从节点出现问题而发生更改时，需要及时修改应用程序读写Redis数据的连接；连接的切换可以手动进行，或者自己写监控程序进行切换，但前者响应慢、容易出错，后者实现复杂，成本都不算低。


---

### 哨兵机制

#### 哨兵的核心功能是主节点的自动故障转移。

#### 哨兵实现了什么功能

- 监控（Monitoring）：哨兵会不断地检查主节点和从节点是否运作正常。

- 自动故障转移（Automatic failover）：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。
- 配置提供者（Configuration provider）：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。
- 通知（Notification）：哨兵可以将故障转移的结果发送给客户端。

#### 哨兵集群的组建

哨兵实例之间可以相互发现，要归功于 Redis 提供的 pub/sub 机制，也就是发布 / 订阅机制。

#### 哨兵监控Redis库

这是由哨兵向主库发送 INFO 命令来完成的。

哨兵 2 给主库发送 INFO 命令，主库接受到这个命令后，就会把从库列表返回给哨兵。接着，哨兵就可以根据从库列表中的连接信息，和每个从库建立连接，并在这个连接上持续地对从库进行监控。哨兵 1 和 3 可以通过相同的方法和从库建立连接。

#### 主库下线的判定

- 主观下线：任何一个哨兵都是可以监控探测，并作出Redis节点下线的判断；
- 客观下线：有哨兵集群共同决定Redis节点是否下线；

当某个哨兵判断主库“主观下线”后，会给其他哨兵发送 is-master-down-by-addr 命令。其他哨兵根据自己与主库的连接情况，做出 Y 或 N 的响应。

如果赞成票大于等于配置文件中的 quorum 配置项，可以判定主库 客观下线。

#### 哨兵集群的选举

判断完主库下线后，由哪个哨兵节点来执行主从切换呢？这里就需要哨兵集群的选举机制了。

为了避免哨兵的单点情况发生，所以需要一个哨兵的分布式集群。作为分布式集群，必然涉及共识问题（即选举问题）；同时故障的转移和通知都只需要一个主的哨兵节点就可以了。

哨兵的选举机制其实很简单，就是一个 Raft 选举算法： 选举的票数大于等于 num(sentinels)/2+1 时，将成为领导者，如果没有超过，继续选举

- 任何一个想成为 Leader 的哨兵，要满足两个条件：
    + 第一，拿到半数以上的赞成票；
    + 第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。

判定客观下线 和 是否能够主从切换（用到选举机制）

Redis 1主4从，5个哨兵，哨兵配置quorum为2，如果3个哨兵故障，当主库宕机时，哨兵能否判断主库“客观下线”？能否自动切换？

    1. 哨兵集群可以判定主库“主观下线”。由于quorum=2，所以当一个哨兵判断主库“主观下线”后，询问另外一个哨兵后也会得到同样的结果，2个哨兵都判定“主观下线”，达到了quorum的值，因此，哨兵集群可以判定主库为“客观下线”。

    2.但哨兵不能完成主从切换。哨兵标记主库“客观下线后”，在选举“哨兵领导者”时，一个哨兵必须拿到超过多数的选票(5/2+1=3票)。但目前只有2个哨兵活着，无论怎么投票，一个哨兵最多只能拿到2票，永远无法达到N/2+1选票的结果。 ¶ 新主库的选出

#### 新主库的选出

- 过滤掉不健康的（下线或断线），没有回复过 ping 响应的从节点。
- 选择 salve-priority 从节点优先级高（redis.conf）的
- 选择复制偏移量最大，只复制最完整的从节点

#### 故障的转移

流程如下：

- 将slave-1脱离原从节点（PS: 5.0 中应该是replicaof no one)，升级主节点，
- 将从节点slave-2指向新的主节点
- 通知客户端主节点已更换
- 将原主节点（oldMaster）变成从节点，指向新的主节点

---

### 缓存问题： 一致性，穿击，穿透，雪崩，污染等

高并发的业务场景下，数据库大多数情况时用户并发访问最薄弱的环节。使用 redis 做一个缓冲操作，请求先访问 redis ，而不是直接访问 MySQL 等数据库。

#### 缓存穿透

缓存和数据库中都没有数据，而用户不断发起请求。

缓存是不命中时被动写的，出去容错考虑，如果存储层查不到数据则不写入缓存，这个不存在的数据每次请求都要到存储层去查询，失去缓存意义。

- 解决方案：

1. 接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；


2. 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击


3. 布隆过滤器。bloomfilter就类似于一个hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于hash算法和容器大小

#### 缓存击穿

缓存中没有但数据库中有数据，并发用户特别多，同时读缓存没读到数据，又同时去读取数据库，造成数据库压力瞬间增大。

- 解决方案：

1. 设置热点数据永远不过期。


2. 接口限流与熔断，降级。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些 服务 不可用时候，进行熔断，失败快速返回机制。


3. 加互斥锁

#### 缓存雪崩

数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至 down 机。 和缓存击穿不同的是，后者指并发查询同一条数据，雪崩是指不同数据过期，查不到才去查数据库。

- 解决方案：

1.缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。

2. 如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。


3. 设置热点数据永远不过期。

#### 缓存污染（或满了）

缓存中一些只会被访问一次或几次的数据，被访问完后，再也不会被访问到，但依然留再缓存中，消耗空间。

缓存污染会随着数据的持续增加而逐渐显露，随着服务的不断运行，缓存中会存在大量的永远不会再次被访问的数据。缓存空间是有限的，如果缓存空间满了，再往缓存里写数据时就会有额外开销，影响Redis性能。这部分额外开销主要是指写的时候判断淘汰策略，根据淘汰策略去选择要淘汰的数据，然后进行删除操作。

#### 最大缓存设置多大

建议把缓存容量设置为总数据量的 15% 到 30%，兼顾访问性能和内存空间开销。

#### 缓存淘汰策略

八种淘汰策略，分别是noeviction、volatile-random、volatile-ttl、volatile-lru、volatile-lfu、allkeys-lru、allkeys-random 和 allkeys-lfu 策略

- 不淘汰
    - noeviction （v4.0后默认的）


- 对设置了过期时间的数据中进行淘汰
    - 随机：volatile-random
    - ttl：volatile-ttl
    - lru：volatile-lru
    - lfu：volatile-lfu


- 全部数据进行淘汰
    - 随机：allkeys-random
    - lru：allkeys-lru
    - lfu：allkeys-lfu

#### 数据库和缓存一致性

使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问MySQL等数据库：

读取缓存步骤一般没有什么问题，但是一旦涉及到数据更新：数据库和缓存更新，就容易出现缓存（Redis）和数据库（MySQL）间的数据一致性问题。

##### 不管是先写MySQL数据库，再删除Redis缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。

1. 如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。

2. 如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。

#### 更新缓存的的Design Pattern有四种

节选最最常用的Cache Aside Pattern, 总结来说就是
- 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
- 更新的时候，先更新数据库，然后再删除缓存。




